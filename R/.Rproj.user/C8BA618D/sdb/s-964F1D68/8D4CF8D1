{
    "contents" : "# We need two object types:  theta list, and individual list members.\n# Class 'theta' will be a list of theta members, possibly with attributes.\n# Theta members will be vectors: low init up, with a fixed attribute.\n# Need get/set functions for individual members, and possibly for list as whole.\n# Need to support subset and element select on list.\n# Need to support conversion to character.\n# Need to support get/set fixed status.\n\nas.init <- function(x,...)UseMethod('as.init')\nas.init.init <- function(x=numeric(0),fixed=FALSE,comment=character(0),...)as.init.numeric(x=x,fixed=fixed,comment=comment,...)\nas.init.numeric <- function(x=numeric(0),fixed=FALSE,comment=character(0),...){\n    #x may be one,two, or three values\n\t#init, low/init, or low/init/up\n\tstopifnot(length(x)<=3,is.logical(fixed),inherits(comment,'character'))\n\ty <- c(-Inf,NA,Inf)\n\tnames(y) <- c('low','init','up')\n\tclass(y) <- c('init',class(y))\n\tif(length(x)==1)y['init'] <- x\n\tif(length(x)==2)y[c('low','init')] <- x\n\tif(length(x)==3)y[c('low','init','up')] <- x\n\tif(is.na(y['low']))y['low'] <- -Inf\n\tif(is.na(y['up']))y['up'] <- Inf\n  if(y['low'] > y['up']) stop('lower bound must not be greater than upper bound')\n  if(!is.na(y['init']))stopifnot(y['low'] <= y['init'],y['init'] <= y['up'])\n  if(fixed & is.na(y['init']))stop('initial cannot be fixed if missing')\n  if(!fixed & !is.na(y['init']) & y['init']==0)stop('initial cannot be fixed to zero')\n\tif(fixed) y[c('low','init','up')] <- y['init']\n  if(length(comment))comment(y) <- comment\n\ty\n}\nas.character.init <- function(x,...){\n  fixed <- x['low']==x['init'] & x['init']==x['up']\n  com <- comment(x)\n  if(is.na(fixed))fixed <- FALSE\n  if(!is.na(x['init']) & all(is.infinite(x[c('low','up')]))) x <- x['init']\n  if(!is.na(x['init']) & is.infinite(x['up'])) x <- x[c('low','init')]\n  x[] <- sapply(x,toupper)\n  x[is.na(x)] <- ''\n  if(fixed) x <- x['init']\n  len <- length(x)\n  y <- paste(x,collapse=',')\n  if(len>1) y <- parens(y)\n  if(fixed) y <- paste(y,'FIXED')\n  if(!is.null(com)) {\n    com <- as.character(com)\n    if(length(com)==1)y <- paste(y,com, sep='; ')\n    if(length(com)>1){\n      com <- paste('; ',com)\n      y <- c(y,com)\n    }\n  }\n  y\n}\nformat.init <-function(x,...)as.character(x,...)\nprint.init <-function(x,...)print(format(x,...))\nfixed <- function(x,...)UseMethod('fixed')\n`fixed<-` <- function(x,value)UseMethod('fixed<-')\nfixed.init <- function(x,...)!any(is.na(x)) & length(unique(x)) == 1\n`fixed<-.init` <- function(x,value){\n  stopifnot(is.logical(value))\n  if(is.na(value))stop('NA found where logical required')\n  if(fixed(x)==value)return(x)\n  if(is.na(x['init']))stop(\"cannot alter 'fixed' for a missing value\")\n  if(value)x[c('low','init','up')] <- x['init']\n  else{\n    #user has requested 'not fixed' on something that is 'fixed'\n    x['low'] <- -Inf\n    x['up'] <- Inf\n  }\n  x\n}\n\nas.initList <- function(x,...)UseMethod('as.initList')\nas.initList.list <- function(x,comment=character(0),...){\n  stopifnot(length(x)>0,is.character(comment))\n  is.init <- sapply(x,inherits,'init')\n  class(x) <- c('initList',class(x))\n  if(length(comment)) comment(x) <- comment\n  x\n}\nas.character.initList <- function(x,...){\n  com <- comment(x)\n  if(is.null(com))com <- ''\n  else com <- c('',paste(';',com))\n  y <- c(com,unlist(lapply(x,as.character)))\n  y\n}\nformat.initList <-function(x,...)as.character(x,...)\nprint.initList <-function(x,...)print(format(x,...))\n.comments <- function(x)sub('^[^;]*;?(.*)$','\\\\1',x)\n.space2comma <- function(x){\n  if(!length(x))return(x)\n  x[[1]] <- gsub(' ',',',x[[1]])\n  x\n}\n.explicit <- function(x){\n    halves <- strsplit(x,')',fixed=TRUE)\n    halves <- lapply(halves,.space2comma)\n  }\n`[.initList` <- function (x, ..., drop = TRUE){\n  cl <- oldClass(x)\n  class(x) <- NULL\n  val <- NextMethod(\"[\")\n  class(val) <- cl\n  val\n}\nas.initList.numeric <- function(x,fixed=FALSE,comment=character(0),...){\n  stopifnot(is.logical(fixed),is.character(comment))\n  fixed <- rep(fixed,length.out=length(x))\n  y <- lapply(\n    seq_along(x),\n    function(i)as.init(x[[i]],fixed=fixed[[i]])\n  )\n  y <- as.initList(y)\n  if(length(comment)) comment(y) <- comment\n  y\n}\n`$.init` <- function(x,name)x[[name]]\n`$<-.init` <- function(x,name,value){\n  if(!name %in% c('low','init','up'))stop('attempt to set an invalid init element')\n  if(is.null(value))stop('attempt to delete a required init element')\n  x[name] <- value\n  x\n}\nfixed.initList <- function(x,...)sapply(x,fixed)\n`fixed<-.initList` <- function(x,value){\n\tstopifnot(is.logical(value))\n\tvalue <- rep(value,length.out=length(x))\n\tfor(i in seq_along(value))fixed(x[[i]]) <- value[[i]]\n\tx\n}\n.initcomments <- function(x)sub('^[^;]*;?(.*)$','\\\\1',x)\n.initdata <- function(x)sub(';.*','',x)\n.initEstimateNum <- function(x){\n  # an estimate is initiated by a parenthesis, or by a qualifying character.\n  # a qualifying character is a numeric or reserved char.\n  # if initiated by parenthesis, it is closed by parenthesis, else by next\n  # qualifying character\n  # only 0123456789.-+eI( can initiate an estimate. For (, only ) can close it. For the others,\n  # the first space or newline ends the numeric region.\n  y <- numeric(0)\n  openers <- c('0','1','2','3','4','5','6','7','8','9','.','-','+','(')\n  closers <- c(' ','\\n','\\t') #or end of vector\n  region <- 0\n  parenthetical <- FALSE\n  active <- FALSE\n  for(i in x){\n    if(!active){\n      if(i %in% openers){\n        region <- region + 1\n        active <- TRUE\n      }\n    }else{\n      if(parenthetical){\n        if(i==')') active <- FALSE\n      }else{\n        if(i %in% closers) active <- FALSE\n      }\n    }\n    if(i=='(')parenthetical <- TRUE\n    if(i==')')parenthetical <- FALSE\n    y <- append(y,region)\n  }\n  y\n}\n\n.initLineNum <- function(x){\n  newline <- x=='\\n'\n  #I am the first character in a line if I follow a newline, or if I am the veryfirst character.\n  frst <- prev(newline)\n  frst[is.na(frst)] <- TRUE\n  linenum <- cumsum(frst)\n  linenum\n}\nas.initList.character <- function(x,...){\n  stopifnot(length(x)>0)\n  comments <- .initcomments(x)\n  data <- .initdata(x)\n  data <- paste(data,collapse='\\n')\n  z <- strsplit(data,NULL)[[1]]\n  #classify each character in z as belonging to a particular line and particular estimate.\n  est <- .initEstimateNum(z)\n  line <- .initLineNum(z)\n  inits <- split(z,est)\n  inits <- lapply(inits,paste,collapse='')\n  globalcom <- comments[unique(line[est==0])]\n  if(0 %in% est) inits <- inits[-1]\n  inits <- lapply(\n    seq_along(inits),\n    function(i){\n      x <- inits[[i]]\n      com <- comments[.initRelComment(i,est,line)]\n      com <- com[com!='']\n      comment(x) <- com\n      x\n    }\n  )\n  inits <- lapply(\n    seq_along(inits),\n    function(i){\n      com <- comment(inits[[i]])\n      if(is.null(com))com <- character(0)\n      out <- .as.init.character(inits[[i]],comment=com)\n      out\n    }\n  )\n  as.initList(inits,comment=globalcom)\n}\n.initRelComment <- function(i,est,line){\n  #need numbers for comment lines for any comment on my line, plus any trailing\n  #comments, i.e. those after this line but before a new est is started\n  #use comment groups: where runhead est coincides with runhead line\n  stopifnot(length(est)==length(line))\n  groupstart <- runhead(est) & runhead(line)\n  group <- cumsum(groupstart)\n  mygroup <- unique(group[est==i])#probably only 1\n  mylines <- unique(line[group==mygroup])\n  mylines\n}\n.as.init.character <- function(x,comment=character(0),...){#limited utility\n  stopifnot(length(x)==1)\n  fixed = FALSE\n  if(x %contains% 'FIX|FIXED') fixed <- TRUE\n  x <- gsub('FIXED','',x)\n  x <- gsub('FIX','',x)\n  x <- gsub('\\n','',x)\n  x <- sub('(','',x,fixed=TRUE)\n  x <- sub(')','',x,fixed=TRUE)\n  x <- gsub(' +',' ',x)\n  x <- sub('^ ','',x)\n  x <- sub(' $','',x)\n  x <- gsub(',? ',',',x)\n  x <- strsplit(x,',')[[1]]\n  x <- as.numeric(x)\n  x <- as.init(x,fixed=fixed,comment=comment,...)\n  x\n}\n",
    "created" : 1335991296722.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "hash" : "725996921",
    "id" : "8D4CF8D1",
    "lastKnownWriteTime" : 1336085645,
    "path" : "~/project/metrumrg/R/as.init.R",
    "properties" : {
    },
    "source_on_save" : true,
    "type" : "r_source"
}