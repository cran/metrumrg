{
    "contents" : "\\name{as.nmctl}\n\\alias{as.nmctl}\n\\alias{as.character.nmctl}\n\\alias{as.list.nmctl}\n\\alias{as.nmctl.character}\n\\alias{format.nmctl}\n\\alias{print.nmctl}\n\\alias{read.nmctl}\n\\alias{write.nmctl}\n\\alias{[.nmctl}\n\\alias{[[.nmctl}\n\n\\title{\nCreate, Manipulate, Read, and Write NONMEM Control Streams\n}\n\\description{\nThis family of functions implements the class \\code{nmctl}: an object\nmodel of the NONMEM control stream.  \\code{nmctl} models a control stream\nas a list of records; each record is a character vector. The read and write \nfunctions (not generic) convert \\code{nmctl} to and from file format.  The \nprint, format, and \\code{as.character} methods display \\code{nmctl} as it normally looks\nin a text editor.  \\code{as.list.nmctl} simply unclasses its argument.\n\\code{as.nmctl.character} does the heavy work, breaking up a character\nvector into records and storing as a list.  If \\code{parse} is \\code{TRUE}, \n\\code{as.nmctl} attempts to convert certain records to higher-level objects: currently\nthe \\code{theta} record will be converted to \\code{\\link{initList}} See \\code{\\link{autolog.pl}}.\n}\n\\usage{\n\\method{as.character}{nmctl}(x, ...)\n\\method{as.list}{nmctl}(x, ...)\n\\method{as.nmctl}{character}(\n\tx,\n\tpattern='^ *\\\\\\\\$([^ ]+)( .*)?$',\n\thead='\\\\\\\\1',\n\ttail='\\\\\\\\2',\n  parse=FALSE,\n\t...\n)\n\\method{format}{nmctl}(x, ...)\n\\method{print}{nmctl}(x, ...)\nread.nmctl(con,parse=FALSE, ...)\nwrite.nmctl(\n\tx, \n\tfile = \"data\", \n\tncolumns = 1, \n\tappend = FALSE, \n\tsep = \" \", \n\t...\n)\n\\method{[}{nmctl}(x, ..., drop = TRUE)\n\\method{[[}{nmctl}(x, ..., drop = TRUE)\n}\n\n\\arguments{\n  \\item{x}{an nmctl object (or analogous character vector)}\n  \\item{\\dots}{extra arguments passed to other functions}\n  \\item{pattern}{regular expression for first line of a control record}\n  \\item{head}{regular expression (relative to \\code{pattern}) giving the name of the control record}\n  \\item{tail}{regular expression (relative to \\code{pattern}) giving the balance of the control record}\n  \\item{con}{a connection or the name of a file to open}\n  \\item{parse}{whether to create R objects from the character vectors serving as records}\n  \\item{file}{passed to \\code{write}}\n  \\item{ncolumns}{passed to \\code{write}}\n  \\item{append}{passed to \\code{write}}\n  \\item{sep}{passed to \\code{write}}\n  \\item{drop}{coerce to lowest possible dimension}\n}\n\\details{\nSerendipitously, the record indicator in NONMEM control stream syntax is the \nsame as the element selector in R list syntax: $.  The convention is that names\nof elements in \\code{nmctl} (lower case) are converted to record types (upper case)\nin the control stream.  The user is free to add, delete, rearrange, and edit\nrecords using standard list manipulation techniques. When printed, records \nappear in list order. The write function warns if the 80 character limit is exceeded\n(not including comments).\n\n\n}\n\\value{\n\\item{as.character.nmctl }{a character vector representing a control stream}\n\\item{as.list }{a list representing a control stream}\n\\item{as.nmctl.character }{a control stream object}\n\\item{format.nmctl }{character}\n\\item{print.nmctl }{character}\n\\item{read.nmctl}{a control stream object}\n\\item{write.nmctl }{used for side effects}\n}\n\\references{\\url{http://metrumrg.googlecode.com}}\n\\author{Tim Bergsma}\n\\seealso{\n\t\\itemize{\n  \t\\item \\code{\\link{as.initList}}\n  \t\\item \\code{\\link{write}}\n\t}\n}\n\\keyword{manip}\n\n",
    "created" : 1336085881766.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "hash" : "3670155092",
    "id" : "3D2ADFA6",
    "lastKnownWriteTime" : 1336086918,
    "path" : "~/project/metrumrg/man/as.nmctl.Rd",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_doc"
}